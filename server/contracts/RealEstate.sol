// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.15;

import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";
import '../node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol';
import "../node_modules/@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title RealEstate
 * @notice Real Estate Properties Tokenization contract
 * @dev RealEstate contract is an implementation of ERC721 openzeppelin contract to mint and transfer NFTs
 * @author Hela CHERIF
 */
contract RealEstate is Ownable, ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    Counters.Counter private _propertyId;

    /// @dev Structure of Property
    struct Property {
        uint id;
        string name;
        string description;
        bool isPublished;
        PropertyAddress propertyAddress;
        FinancialInfos financialInfos;
    }

    /// @dev Structure of PropertyAddress
    struct PropertyAddress {
        uint256 postalCode;
        string addr;
        string city;
        string complementAddress;
    }

    /// @dev Structure of FinancialInfos
    struct FinancialInfos {
        uint256 tokensNumber;
        uint256 annualYield;
        uint256 propertyPrice;
        uint256 tokenPrice;
    }

    /// @dev Structure of Token
    struct Token {
        uint id;
        uint propertyId;
        address ownerAddress;
        string name;
        string url;
    }

    mapping(address => Token[]) public clientsTokens;
    Property[] public allProperties;
    Token[] public allTokens;
    address public creator;


    // ::::::::::::::::::::::::::::: CONSTRUCTOR :::::::::::::::::::::::::: //

    constructor() ERC721("RealEstate", "RealEstate") payable {
        creator=msg.sender;
    }

    // ::::::::::::::::::::::::::::::: GETTERS ::::::::::::::::::::::::::::: //

    /**
     * @dev Get property
     * @param _id of the property
     * @return property
     */
    function getProperty(uint _id) public view returns (Property memory) {
        return allProperties[_id];
    }

    /**
     * @dev Get Token
     * @param _id of the token
     * @return token
     */
    function getToken(uint _id) public view returns (Token memory) {
        return allTokens[_id];
    }


    function getAllProperties() public view returns( Property[] memory){
        return allProperties;
    }

    function getAllTokens() public view returns(Token[] memory){
        return allTokens;
    }

    // ::::::::::::::::::::::::::::::: EVENTS :::::::::::::::::::::::::::::: //

    /**
     * @dev Emit an event when the property is added
     * @param id of the property
     * @return Event PropertyAdded
     */
    event PropertyAdded(uint id);

    /**
     * @dev Emit an event when the property is updated
     * @param id of the property
     * @return Event PropertyUpdated
     */
    event PropertyUpdated(uint id);

    /**
     * @dev Emit an event when the property is deleted
     * @param id of the property
     * @return Event PropertyDeleted
     */
    event PropertyDeleted(uint id);

    /**
     * @dev Emit an event when the property is published (ready to be minted)
     * @param id of the property
     * @return Event PropertyPublished
     */
    event PropertyPublished(uint id);

    /**
     * @dev Emit an event when the Token NFT is minted
     * @param to of address of the owner
     * @param tokenId of the Token
     * @return Event MintToken
     */
    event MintToken(address indexed to, uint tokenId);

    /**
     * @dev Emit an event when the Property is fully NFT minted
     * @param to of address of the owner
     * @param tokens list of tokens minted
     * @return Event MintProperty
     */
    event MintProperty(address indexed to, Token[] tokens);

    /**
     * @dev Emit an event when the NFT token is transferred
     * @param to of address of the owner
     * @param tokenId transferred
     * @return Event TransferToken
     */
    event TransferToken(address indexed to, uint tokenId);

    /**
    * @dev Emit an event when a new client is added
     * @param addr transferred
     * @return Event ClientAdded
     */
    event ClientAddedAndApproved(address addr);

    // :::::::::::::::::::::::::::: FUNCTIONS :::::::::::::::::::::::: //


    /**
     * @dev Add a new property only by the owner , the id is generated by the contract
     * @param _property of proposal
     */
    function addProperty(Property memory _property) external onlyOwner {
        require(keccak256(abi.encode(_property.name)) != keccak256(abi.encode("")),
            'The name of the property is mandatory');
        require(_property.financialInfos.propertyPrice > 0,
            'The price of the property should be superior to 0');
        require(_property.financialInfos.tokensNumber > 0,
            'The token number of the property should be superior to 0');
        _property.id = _propertyId.current();
        allProperties.push(_property);
        _propertyId.increment();
        emit PropertyAdded(_property.id);
    }

    /**
     * @dev Update an existing property only by the owner
     * @param _property of proposal
     */
    function updateProperty(Property memory _property) external onlyOwner {
        require(_property.id < allProperties.length, 'The _property does not exist');
        allProperties[_property.id] = _property;
        emit PropertyUpdated(_property.id);
    }

    /**
     * @dev Delete an existing property only by the owner
     * @param _id of the property
     */
    function deleteProperty(uint256 _id) external onlyOwner {
        delete allProperties[_id];
        emit PropertyDeleted(_id);
    }

    /**
     * @dev Publish an existing property only by the owner
     * @param _id of the property
     */
    function publishProperty(uint256 _id) external onlyOwner {
        allProperties[_id].isPublished = true;
        emit PropertyPublished(_id);
    }

    // :::::::::::::::::::::::::: FUNCTIONS ERC721 :::::::::::::::::::::::: //

    /**
     * @dev Mint all the tokens of an existing property only by the owner
     * @param _id : id of the property to be minted
     */
    function mintProperty(uint256 _id) payable external onlyOwner {
        Property memory property = getProperty(_id);
        require(property.isPublished, "The property is not published yet");
        // Mint all the tokens of the property
        for (uint i = 0; i < property.financialInfos.tokensNumber; i++) {
            _safeMint(msg.sender, _tokenIds.current());
            Token memory token;
            token.id = _tokenIds.current();
            token.ownerAddress = msg.sender;
            token.name = "Real Estate NFT";
            token.propertyId = _id;
            token.url = baseURI();
            allTokens.push(token);
            emit MintToken(msg.sender, _tokenIds.current());
            _tokenIds.increment();
        }
        emit MintProperty(msg.sender, allTokens);
    }

    /**
     * @dev Add a new client and approved it by the owner
     * @param _addr of the client
     */
    function approveClient(address _addr) internal onlyOwner {
        setApprovalForAll(_addr, true);
        emit ClientAddedAndApproved(_addr);
    }

    /**
     * @dev Transfers ERC721 token from owner to client
     * @param _to address of the client
     * @param _tokenId of the token
     */
    //
    function transferTo(address _to, uint256 _tokenId) public payable {
        Token memory token = getToken(_tokenId);
        Property memory property = getProperty(token.propertyId);
        require(msg.value >= property.financialInfos.tokenPrice, "Insufficient Funds");
        // First transaction for this client so we should approved him to use all NFT
        if (clientsTokens[_to].length == 0) {
            approveClient(_to);
        }
        approve(_to, _tokenId);
        safeTransferFrom(msg.sender, _to, _tokenId, "0x");
        //Change the owner of the token
        allTokens[_tokenId].ownerAddress = _to;
        token.ownerAddress = _to;
        clientsTokens[_to].push(token);
        emit TransferToken(_to, _tokenId);
    }

    // :::::::::::::::::::::::::::::::::::: OTHER FUNCTIONS  ::::::::::::::::::::::::::::::::::::: //

    fallback() external payable {
    }

    receive() external payable {
    }
    /**
    * @dev Get IPFS Address
     * @return url
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return "https://ipfs.io/ipfs/QmSrSwboxekwhUfK5nKcbzK6xuTmNxhsiz643pmjqJfqPt/";
    }

    /**
     * @dev Get Base URL
     * @return url
     */
    function baseURI() public view returns (string memory) {
        return _baseURI();
    }

}